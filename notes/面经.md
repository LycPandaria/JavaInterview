# 1 数据库
参考资料: [数据库系统](./数据库系统.md)

## 1.1 Mysql

### 1.1.1 参考资料:
[MySQL](./MySQL.md)

### 1.1.2 mysql优化
问了mysql的优化，我说了分表分库，把需要频繁更新的数据和不需要频道更新的数据分库这些，最后面试官问能不能针对mysql本身优化

    答:[分表分库](./MySQL.md#五切分)，[读写分离](./MySQL.md#六复制)，

    [MySQL优化](http://www.codeceo.com/article/mysql-optimization.html)

### 1.1.3 数据库的索引结构？B+树的结构？与B树的区别
[参考](./MySQL.md#一索引)


## 1.2 Redis

# 2 Java

## 2.1 多线程

### 多线程算法题
1. 多线程实现a*b+c/d
```java
// 自己写的
public class JavaInterview {
	static double compute(int a, int b, int c, int d) throws Exception {
		FutureTask<Double> futureTask = new FutureTask<>(new Callable<Double>() {
			@Override
			public Double call() throws Exception {
				return (double) (a*b+c/d);
			}
		});

		Thread computer = new Thread(futureTask);
		computer.start();
		while(!futureTask.isDone()) {
			Thread.sleep(100);
		}
		return futureTask.get();
	}
	public static final void main(String args[]) throws Exception{
		// 多线程计算 a*b+c/d
		// 用 future task
		double res = compute(5, 5, 5, 5);
		System.out.println("res:" + res);
	}
}
```

2. 多线程实现“线程1-1，线程2-2，线程1-3....”(类似输出 ABABABA 那种)
```java
public static int i = 1;
public static boolean flagA = true;
// 多线程实现“线程1-1，线程2-2，线程1-3....”
public static void printByOrder() {
  byte[] block = new byte[0];

  ExecutorService executorService = Executors.newCachedThreadPool();

  for(int j = 0; j < 2; j++) {
    executorService.execute(() -> {
      synchronized (block) {
        try {
            while(i++ <= 10) {
              block.notifyAll();	// 说明其他线程可以进入等待状态，但是由于 synchronized 的原因，锁还是在该线程这里
              //System.out.println(Thread.currentThread().getName() + "-" + i++);
              if(flagA) System.out.println("A");
              else System.out.println("B");
              flagA = !flagA;
            block.wait();
            }
        }catch (Exception e) {
        e.printStackTrace();
      }finally {
        block.notifyAll();
      }
      }
      });
  }
}
```

### 线程池

#### 线程池是什么？怎么用？有什么好处？线程池的核心参数？
管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。

```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) {
}
```

[参考](./Java并发-线程机制.md)

## 2.2 JVM
### 2.2.1 JVM内存结构？
程序计数器，Java虚拟机栈，本地方法栈，堆，方法区（包含运行时常量池）

[参考](./Java虚拟机.md##一运行时数据区域)

### 2.2.2 OOM的场景？（OutOfMemory）
1. OOM for Heap  (java.lang.OutOfMemoryError: Java heap space)
  可以通过 -Xmx 调高heap的最大值。
2. OOM for StackOverflowError  (Exception in thread "main" java.lang.StackOverflowError)
  如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。检查程序是否有深度递归。
3. OOM for Perm  (java.lang.OutOfMemoryError: PermGen space)
  Class在被Loader时就会被放到PermGen space中,它和存放类实例(Instance)的Heap区域不同,GC(Garbage Collection)不会在主程序运行期对PermGen space进行清理，所以如果你的应用中有很多CLASS的话,就很可能出现PermGen space错误,这种错误常见在web服务器对JSP进行pre compile的时候。如果你的WEB APP下都用了大量的第三方jar, 其大小超过了jvm默认的大小那么就会产生此错误信息
4. OOM for GC  (java.lang.OutOfMemoryError: GC overhead limit exceeded)
  此OOM是由于JVM在GC时，对象过多，导致内存溢出（例如老年代进行空间分配担保失败，触发Full GC之后老年代内存还是不够时），建议调整GC的策略，在一定比例下开始GC而不要使用默认的策略，或者将新代和老代设置合适的大小，需要进行微调存活率。

  改变GC策略，在老代80%时就是开始GC，并且将-XX:SurvivorRatio（-XX:SurvivorRatio=8）和-XX:NewRatio（-XX:NewRatio=4）设置的更合理。
5. OOM for native thread created  (java.lang.OutOfMemoryError: unable to create new native thread)
  这个异常问题本质原因是我们创建了太多的线程，而能创建的线程数是有限制的，导致了异常的发生。

6. OOM for allocate huge array  (Exception in thread "main": java.lang.OutOfMemoryError: Requested array size exceeds VM limit)
  应用程序试图分配一个大于堆大小的数组。



## 2.3 锁，synchronized, lock
0. 参考资料：[Java并发](./Java并发.md#互斥同步)

## 2.4 Java容器
### HashMap
#### HashMap的扩容机制？存储的方式？hash后码相同时怎么处理？
[参考](./Java容器.md#hashmap)

# 分布式

# 中间件


# 3 算法
##3.1 参考资料

##3.2 微信红包分钱
微信红包分钱，100块钱，10个人，每个人分的钱不低于1块，不高于30块


    答：有两种做法:一种是从$leave里面随机 0 ~ ($max - $min)之间的数(可以是浮点数),然后随机用户的数组,抽取一个,
    判断两者相加是否大于$max,如果大于,跳过;小于的话就把相加的结果赋值给该用户. 另一种做法是先随机抽取一个用户,
    在根据用户对比$max的差值随机一个数,再相加给该用户.
    ```java
    // 微信红包分钱，100块钱，10个人，每个人分的钱不低于1块，不高于30块
  	// 先随机抽取一个用户,在根据用户对比max的差值随机一个数,再相加给该用户
  	static void redPackets() {
  		Random random = new Random();
  		int count = 10, min = 1, max = 30, left = 100;

  		int packets[] = new int[count];	//	10个红包
  		for(int i = 0; i < count; i ++)
  			packets[i]=min;
  		left -= (min * count);

  		while(left > 0) {
  			int i = random.nextInt(count); // 随机一个红包
  			if(packets[i] >= max)		// 该红包已经达最大限额
  				continue;
  			int r = Math.min(left, max - packets[i]);	//	随机范围，left 和 该红包数额与最大的差值
  			int v = random.nextInt(r) + 1;					// 随机一个金额
  			packets[i] += v;
  			left -= v;

  		}

  		for(int i = 0; i < count; i ++)
  			System.out.println(i + "th:" + packets[i]);
  		return;
  	}
    ```
##3.3 数组交集
给定两个数组，求两个数组的交集，且重复多少次，就打印几次
比如：[1,2,2,3,5,7]和[1,1,2,2,2,2,3,3,5,7,8]，结果[1,2,2,3,5,7]

答：可以把两个数组重组成一个频率数组：[1,2,2,3,5,7] -> [0,1,2,1,0,1,0,1]
即为：数字 i 出现的频率为 arr[i], 然后对两个数组进行遍历遍可以知道哪些数字重复并且重复了几次。

还可以只对元素少的数组转换成频率数组，然后遍历第二个数组 arr2[]，如果 freq[arr2[i]] 的值
不等于0，说明 arr2[i] 的数字在 arr1[] 中是重复的，就打印改数字，并 freq[arr2[i]]--，这样也可以做到重复几次打印几次。
