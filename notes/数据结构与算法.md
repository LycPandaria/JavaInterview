# 链表
## 1-链表的增删改查
```java
class Node{
  Node next = null;
  int data;
  public Node(int data){
    this.data = data;
  }
}
```
下面链表操作给出了链表的基本操作
```java
public class MyLinkedList{
  Node head = null;
  // 插入数据
  public void addNode(int d){
    Node node = new Node(d);
    if(head == null){
      head = node;  // 设置头结点
      return;
    }
    Node tmp = head;  // 从头遍历
    while(tmp.next != null)
      tmp = tmp.next;
    // add node to end
    tmp.next=node;
  }

  //删除第index个节点。
  public Boolean deleteNode(int index){
    if(index < 1 || index > length())
      return false;
    if(index==1){
      head = head.next;
      return true;
    }
    int i = 2;  // 从第二个节点开始
    Node preNode = head;
    Node curNode = preNode.next;
    while(curNode != null){
      if(i == index){
        preNode.next = curNode.next;
        return true;
      }
      preNode = curNode;
      curNode = curNode.next;
      i++;
    }
    return true;
  }

  // 长度
  public int length(){
    int l = 0;
    Node tmp = head;
    while(tmp!= null){
      l++;
      tmp = tmp.next;
    }
    return l;
  }

  // 链表排序（这个排序方法是冒泡）
  public Node orderList(){
    Node nextNode = null;
    int tmp = 0;
    Node curNode = head;
    whilc(curNode != null){
      nextNode = curNode.next;
      while(nextNode!= null){
        if(curNode.data > nextNode.data){
          tmp = curNode.data;
          curNode.data = nextNode.data;
          nextNode.data = tmp;
        }
        nextNode = nextNode.next;
      }
      curNode = curNode.next;
    }
    return head;
  }

  // 输出列表
  public void printList(){
    Node tmp = head;
    while(tmp != null){
      System.out.println(tmp.data);
      tmp = tmp.next;
    }
  }
}
```

## 2-如何从链表中删除重复数据
1. 最容易想到的办法是遍历列表，将遍历的值放到HashTable中，在遍历过程中，若当前访问的值在
HashTable中，说明是重复的。
```java
public void deleteDuplecate(Node head){
  Hashtable<Integer,Integer> table = new Hashtable<Integer,Integer>();
  Node tmp = head;
  Node pre = null;
  while(tmp != null){
    if(table.containsKey(tmp.data))
      pre.next = tmp.next;
    else{
      table.put(tmp.data,1);
      pre = tmp;
    }
    tmp = tmp.next;
  }
}
```
这种方法时间复杂度低，但是需要额外的储存空间来保存已遍历过的值。
2. 对链表进行双重遍历循环*(像冒泡那样)。这种方法不需要额外的存储空间，但是时间复杂度比上面的高。
```java
public void deleteDuplecate(Node head){
  Node p = head;
  while(p != null){
    Node q = p;
    while(q.next != null){ // q会从p节点开始遍历p到链表结尾
      if(p.date == q.next.data)
        q.next = q.next.next; //删除重复数据
      else
        q = q.next;
    }
    p = p.next;
  }
}
```

## 3-找出单链表中倒数第k个元素
1. 比较容易想到的是先遍历一遍算出链表的节点个数n，然后再遍历到第n-k个元素。但是这种方式需要遍历两次列表。
2. 还有一种做法是对于每个节点，遍历k个元素，如果刚好到结尾，那么那个节点就是倒数第k个节点。这种办法的问题在于
对同一批元素进行反复多次的遍历，时间复杂度为O(kn)，效率太低。
3. 更高效的方法是：设置两个指针，让其中一个比另一个先行**k-1**步，这样，当先行的指针到链表尾部时候，后行指针所指位置就是所要找的位置。
```java
//寻找倒数第k个元素
public Node findElemFromEnd(Node head, int k){
  if(k < 1)
    return null;
  Node p1 = head;
  Node p2 = head;
  // p1 先行k步
  for(int i = 0; i < k-1 && p1 != null;i++)
    p1 = p1.next;
  if(p1 == null){
    System.out.println("k不合法")
    return null;
  }
  while(p1.next != null){
    p1 = p1.next;
    p2 = p2.next;
  }
  return p2;
}
```

## 4-链表的反转
链表的反转需要注意的是，比如i,m,n 3个相连节点，i节点已经完成反转，在处理m节点的时候，不能直接将
m.next=i；因为这样的话就没有办法能够找到n，因为链接断裂，所以在处理m.next之前需要将n保存下来。
```java
public void ReserveList(Node head){
  Node pReservedHead = head;
  Node pNode = head;
  Node pPrev = null;
  while(pNode != null){
    Node pNext = pNode.next;  // 保存当前节点的next节点
    if(pNext == null) // 尾节点
      pReservedHead = pNode;  // 反转前的尾节点成为头结点
    pNode.next = pPrev;
    pPrev = pNode;
    pNode = pNext;
  }
  this.head = pReservedHead;
}
```

## 5-从尾到头输出单链表
1. 从上面得到启发，先反转链表再输出。
2. 遍历一遍列表，然后将每个元素放入一个栈中，然后输出栈。这样只需要遍历一次，但是需要维护一个
栈空间，实现比较麻烦。
3. 其实**递归本质上就是一个栈的结构，所以可以用递归来实现**
```java
public void printListReversely(Node head){
  if(head != null){
    printListReversely(head.next);
    System.out.println(head.data);
  }
}
```
