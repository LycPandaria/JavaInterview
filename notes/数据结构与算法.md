# 链表
## 1-链表的增删改查
```java
class Node{
  Node next = null;
  int data;
  public Node(int data){
    this.data = data;
  }
}
```
下面链表操作给出了链表的基本操作
```java
public class MyLinkedList{
  Node head = null;
  // 插入数据
  public void addNode(int d){
    Node node = new Node(d);
    if(head == null){
      head = node;  // 设置头结点
      return;
    }
    Node tmp = head;  // 从头遍历
    while(tmp.next != null)
      tmp = tmp.next;
    // add node to end
    tmp.next=node;
  }

  //删除第index个节点。
  public Boolean deleteNode(int index){
    if(index < 1 || index > length())
      return false;
    if(index==1){
      head = head.next;
      return true;
    }
    int i = 2;  // 从第二个节点开始
    Node preNode = head;
    Node curNode = preNode.next;
    while(curNode != null){
      if(i == index){
        preNode.next = curNode.next;
        return true;
      }
      preNode = curNode;
      curNode = curNode.next;
      i++;
    }
    return true;
  }

  // 长度
  public int length(){
    int l = 0;
    Node tmp = head;
    while(tmp!= null){
      l++;
      tmp = tmp.next;
    }
    return l;
  }

  // 链表排序（这个排序方法是冒泡）
  public Node orderList(){
    Node nextNode = null;
    int tmp = 0;
    Node curNode = head;
    whilc(curNode != null){
      nextNode = curNode.next;
      while(nextNode!= null){
        if(curNode.data > nextNode.data){
          tmp = curNode.data;
          curNode.data = nextNode.data;
          nextNode.data = tmp;
        }
        nextNode = nextNode.next;
      }
      curNode = curNode.next;
    }
    return head;
  }

  // 输出列表
  public void printList(){
    Node tmp = head;
    while(tmp != null){
      System.out.println(tmp.data);
      tmp = tmp.next;
    }
  }
}
```

## 2-如何从链表中删除重复数据
1. 最容易想到的办法是遍历列表，将遍历的值放到HashTable中，在遍历过程中，若当前访问的值在
HashTable中，说明是重复的。
```java
public void deleteDuplecate(Node head){
  Hashtable<Integer,Integer> table = new Hashtable<Integer,Integer>();
  Node tmp = head;
  Node pre = null;
  while(tmp != null){
    if(table.containsKey(tmp.data))
      pre.next = tmp.next;
    else{
      table.put(tmp.data,1);
      pre = tmp;
    }
    tmp = tmp.next;
  }
}
```
这种方法时间复杂度低，但是需要额外的储存空间来保存已遍历过的值。
2. 对链表进行双重遍历循环*(像冒泡那样)。这种方法不需要额外的存储空间，但是时间复杂度比上面的高。
```java
public void deleteDuplecate(Node head){
  Node p = head;
  while(p != null){
    Node q = p;
    while(q.next != null){ // q会从p节点开始遍历p到链表结尾
      if(p.date == q.next.data)
        q.next = q.next.next; //删除重复数据
      else
        q = q.next;
    }
    p = p.next;
  }
}
```

## 3-找出单链表中倒数第k个元素
1. 比较容易想到的是先遍历一遍算出链表的节点个数n，然后再遍历到第n-k个元素。但是这种方式需要遍历两次列表。
2. 还有一种做法是对于每个节点，遍历k个元素，如果刚好到结尾，那么那个节点就是倒数第k个节点。这种办法的问题在于
对同一批元素进行反复多次的遍历，时间复杂度为O(kn)，效率太低。
3. 更高效的方法是：设置两个指针，让其中一个比另一个先行**k-1**步，这样，当先行的指针到链表尾部时候，后行指针所指位置就是所要找的位置。
```java
//寻找倒数第k个元素
public Node findElemFromEnd(Node head, int k){
  if(k < 1)
    return null;
  Node p1 = head;
  Node p2 = head;
  // p1 先行k步
  for(int i = 0; i < k-1 && p1 != null;i++)
    p1 = p1.next;
  if(p1 == null){
    System.out.println("k不合法")
    return null;
  }
  while(p1.next != null){
    p1 = p1.next;
    p2 = p2.next;
  }
  return p2;
}
```

## 4-链表的反转
链表的反转需要注意的是，比如i,m,n 3个相连节点，i节点已经完成反转，在处理m节点的时候，不能直接将
m.next=i；因为这样的话就没有办法能够找到n，因为链接断裂，所以在处理m.next之前需要将n保存下来。
```java
public void ReserveList(Node head){
  Node pReservedHead = head;
  Node pNode = head;
  Node pPrev = null;
  while(pNode != null){
    Node pNext = pNode.next;  // 保存当前节点的next节点
    if(pNext == null) // 尾节点
      pReservedHead = pNode;  // 反转前的尾节点成为头结点
    pNode.next = pPrev;
    pPrev = pNode;
    pNode = pNext;
  }
  this.head = pReservedHead;
}
```

## 5-从尾到头输出单链表
1. 从上面得到启发，先反转链表再输出。
2. 遍历一遍列表，然后将每个元素放入一个栈中，然后输出栈。这样只需要遍历一次，但是需要维护一个
栈空间，实现比较麻烦。
3. 其实**递归本质上就是一个栈的结构，所以可以用递归来实现**
```java
public void printListReversely(Node head){
  if(head != null){
    printListReversely(head.next);
    System.out.println(head.data);
  }
}
```

## 6-寻找单链表中间节点
1. 最容易想到的办法是遍历列表取得长度n，然后遍历到n/2个节点。但是要遍历两次。
2. 优化的方法是用两个指针，一个每次走2步，一个每次走一步。当快指针到达尾部时候，慢指针位置刚好为链表中间节点（当链表长度为基数时，慢指针指向的即为中间指针，当链表长度为偶数时，慢指针所指向的节点和下一个节点都是中间节点）
```java
public Node SearchMid(Node head){
  Node fast = head;
  Node slow = head;
  while(fast =! null && fast.next != null && fast.next.next != null){
    fast = fast.next.next;
    slow = slow.next;
  }
  return slow;
}
```

## 7-监测链表是否有环
同上，快慢两个指针一起走，如果某个时间快指针等于慢指针，则说明有环。如果fast指针先行到尾部为null，则说明没环
```java
public boolean IsLoop(Node head){
  if(head == null)
    return false;
  Node fast = head;
  Node slow = head;
  while(fast != null & fast.next != null){
    fast = fast.next.next;
    slow = slow.next;
    if(fast == slow)
      return true;
  }
  return !(fast == null || fast.next == null);
}
```
寻找环的入口点：   
在找到相遇点后，在链表头和相遇点各设一个指针，每次走一步，两个指针必定相遇且相遇第一点即为环入口点。
```java
public Node findLoopPort(Node head){
  Node slow = head, fast = head;
  // 先找相遇点
  while(fast != null & fast.next != null){
    fast = fast.next.next;
    slow = slow.next;
    if(fast == slow)
      return break;
  }
  if(fast == null || fast.next == null) //这种情况说明链表是没环的
    return null;
  // 开始找环入口点
  // 在链表头和相遇点各设一个指针，每次走一步，两个指针必定相遇且相遇第一点即为环入口点。
  slow = head;
  while(slow != fast){
    slow = slow.next;   
    fast = fast.next;
  }
  return slow;
}
```

## 8-在不知道头指针的情况下删除指定节点
分两种情况：
1. 若待删除的节点是链表的尾节点，则无法删除，因为删除之后无法给前置节点的next设置为null。
2. 若待删除的节点不是尾节点，则可以通过交换这个节点与其后记节点的值，然后删除后继节点。
```java
public boolean deleteNode(Node n){
  if(n == null || n.next == null)
    return false;
  //交换n节点与后继节点的值
  int tmp = n.data;
  n.data = n.next.data;
  n.next.data = tmp;
  //删除后继节点
  n.next = n.next.next;
  return true;
}
```

## 判断两个链表是否相交
若两个链表相交，则他们有着相同的尾节点。
```java
public boolean isIntersect(Node h1, Node h2){
  if(h1 == null || h2 == null)
    return false;
  Node tail1 = h1;
  //找链表1的尾节点
  while(tail1.next != null)
    tail1 = tail1.next;
  Node tail2 = h2;
  while(tail2.next != null)
    tail2 = tail2.next;

  return tail1 == tail2;
}
```
那么如何找出他们相交的第一个点呢？   
首先需要计算两个链表head1，head2长度len1和len2，假设len1>len2,则让head1先遍历（len1-len2）个节点，然后head2开始遍历，这样遇到的第一个相同的节点就是他们相交的点。不过前提条件是他们相交。
```java
public Node getFirstMeetNode(Node h1, Node h2){
  if(h1 == null || h2 == null)
    return false;
  Node tail1 = h1;
  int len1 = 1;
  //找链表1的尾节点
  while(tail1.next != null){
    tail1 = tail1.next;
    len1++;
  }
  Node tail2 = h2;
  int len2 = 1;
  while(tail2.next != null){
    tail2 = tail2.next;
    len2++;
  }
  //两表不相交
  if( tail1 != tail2)
    return null;

  Node t1 = h1;
  Node t2 = h2;
  //先找出较长的链表，并先开始遍历
  if(len1 > len2){
    int d = len1 - len2;
    while(d!=0){
      t1 = t1.next;
      d--;
    }
  }else {
    int d = len2 - len1;
    while(d!=0){
      t2 = t2.next;
      d--;
  }
  while(t1 != t2){
    t1 = t1.next;
    t2 = t2.next;
  }
  return t1;
}
```
