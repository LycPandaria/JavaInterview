# 链表
## 1-链表的增删改查
```java
class Node{
  Node next = null;
  int data;
  public Node(int data){
    this.data = data;
  }
}
```
下面链表操作给出了链表的基本操作
```java
public class MyLinkedList{
  Node head = null;
  // 插入数据
  public void addNode(int d){
    Node node = new Node(d);
    if(head == null){
      head = node;  // 设置头结点
      return;
    }
    Node tmp = head;  // 从头遍历
    while(tmp.next != null)
      tmp = tmp.next;
    // add node to end
    tmp.next=node;
  }

  //删除第index个节点。
  public Boolean deleteNode(int index){
    if(index < 1 || index > length())
      return false;
    if(index==1){
      head = head.next;
      return true;
    }
    int i = 2;  // 从第二个节点开始
    Node preNode = head;
    Node curNode = preNode.next;
    while(curNode != null){
      if(i == index){
        preNode.next = curNode.next;
        return true;
      }
      preNode = curNode;
      curNode = curNode.next;
      i++;
    }
    return true;
  }

  // 长度
  public int length(){
    int l = 0;
    Node tmp = head;
    while(tmp!= null){
      l++;
      tmp = tmp.next;
    }
    return l;
  }

  // 链表排序（这个排序方法是冒泡）
  public Node orderList(){
    Node nextNode = null;
    int tmp = 0;
    Node curNode = head;
    whilc(curNode != null){
      nextNode = curNode.next;
      while(nextNode!= null){
        if(curNode.data > nextNode.data){
          tmp = curNode.data;
          curNode.data = nextNode.data;
          nextNode.data = tmp;
        }
        nextNode = nextNode.next;
      }
      curNode = curNode.next;
    }
    return head;
  }

  // 输出列表
  public void printList(){
    Node tmp = head;
    while(tmp != null){
      System.out.println(tmp.data);
      tmp = tmp.next;
    }
  }
}
```

## 2-如何从链表中删除重复数据
1. 最容易想到的办法是遍历列表，将遍历的值放到HashTable中，在遍历过程中，若当前访问的值在
HashTable中，说明是重复的。
```java
public void deleteDuplecate(Node head){
  Hashtable<Integer,Integer> table = new Hashtable<Integer,Integer>();
  Node tmp = head;
  Node pre = null;
  while(tmp != null){
    if(table.containsKey(tmp.data))
      pre.next = tmp.next;
    else{
      table.put(tmp.data,1);
      pre = tmp;
    }
    tmp = tmp.next;
  }
}
```
这种方法时间复杂度低，但是需要额外的储存空间来保存已遍历过的值。
2. 对链表进行双重遍历循环*(像冒泡那样)。这种方法不需要额外的存储空间，但是时间复杂度比上面的高。
```java
public void deleteDuplecate(Node head){
  Node p = head;
  while(p != null){
    Node q = p;
    while(q.next != null){ // q会从p节点开始遍历p到链表结尾
      if(p.date == q.next.data)
        q.next = q.next.next; //删除重复数据
      else
        q = q.next;
    }
    p = p.next;
  }
}
```
